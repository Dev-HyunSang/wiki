(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{216:function(t,s,r){"use strict";r.r(s);var a=r(0),_=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),s("p",[t._v("소유권(Ownership)은 러스트의 가장 유니크한 특성이며, 러스타가 가비지 컬렉터(Garbage Collection, GC) 없이 메모리 안정성 보장해 준다. 소유권이 러스트 내에서 어떻게 동작하는지 이해하는 것은 중요하다.")]),t._v(" "),s("p",[t._v("모든 프로그램은 실행하는 동안 컴퓨터의 메모리를 사용하는 방법을 관리해야 합니다. 몇몇 언어들은 프로그램이 실행될 때 더이상 사용하지 않는 메모리를 끊임없이 찾는 가비지 콜렉션을 갖고 있습니다. 다른 프로그래밍 언어들에서는 프로그램가 직접 명시적으로 메모리를 할당하고 해제해야 합니다. 러스트는 제 3의 접근법을 이용합니다. 메모리는 컴파일 타임에 컴파일러가 체크할 규칙들로 구성된 소유권 시스템을 통해 관리됩니다. 소유권 기능들의 어떤 것도 런타임 비용이 발생하지 않습니다.")]),t._v(" "),s("p",[t._v("소유권이란 개념이 많은 프로그래머들에게 새로운 것이기 때문에, 이해하고 사요하는 데에는 약간의 시간이 걸립니다만, 좋은 소식은 여러분이 러스트와 소유권 시스템 규칙에 더 많은 경험을 할수록, 여러분은 더 안전하고 효율적인 코드를 자연스럽게 개발할 수 있게 됩니다.")]),t._v(" "),s("p",[t._v("소유권을 이해했을 때, 여러분은 러스트를 유니크하게 만드는 기능들을 이해하기 위한 견고한 기초를 가지게될 것입니다. 여러분은 매우 흔한 데이터 구조인 문자열에 집중된 몇가지 예제를 통해 소유권에 대해 배우게 될 것입니다.")]),t._v(" "),t._m(2),t._v(" "),s("p",[t._v("GC 작업을 하는 가비지 콜렉터는 다음과 같은 일을 한다.")]),t._v(" "),t._m(3),t._v(" "),s("p",[t._v("즉, 메모리가 부족할 때 쓰레기를 정리해주는 프로그램을 가비지 컬렉터라고 부른다. 가비지 컬렉터에 대해서 알기 전에 우선 메모리에 대한 이해가 필요하다.\n프로그램을 실행할 때 메모리를 관리하는 OS에 프로그램 실행에 필요한 메모리를 요청하게 된다. 이때 메모리를 어디에 저장할지 그 주소를 할당하는데 이 주소를 offset 주소라고 부른다.")]),t._v(" "),s("p",[t._v("이 할당된 메모리들은 프로그램이 돌아가면 필연적으로 '가비지'가 발생하게 된다. 기존에 가리키고 있던 메모리를 새롭게 선언되거나 형변환이 되면서 다른 곳을 가리키게 되면서 주소를 잃어버리게 되고 다시 찾을 수 없게 되면서 정리되지 않은 메모리가 생겨버리게 되기 때문이다.")]),t._v(" "),s("p",[t._v("그래서 가비지 컬렉터는 가비지를 다른 용도로 사용할 수 있도록 메모리 해제를 시킨다. 이것이 가비지 컬렉터의 목적이다.")]),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._m(10),t._v(" "),t._m(11),t._m(12),t._v(" "),s("ul",[s("li",[s("strong",[t._v("가비지 컬렉션(Garbage Collection, CG):")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://blog.metafor.kr/163",target:"_blank",rel:"noopener noreferrer"}},[t._v("가비지 컬렉션, 컬렉터(Garbage Collection)란?"),s("OutboundLink")],1)])])]),t._v(" "),t._m(13)])])}),[function(){var t=this._self._c;return t("h1",{attrs:{id:"_20230517-rust-소유권-규칙"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_20230517-rust-소유권-규칙"}},[this._v("#")]),this._v(" 20230517 - Rust 소유권 규칙")])},function(){var t=this._self._c;return t("h2",{attrs:{id:"소유권이란"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#소유권이란"}},[this._v("#")]),this._v(" 소유권이란?")])},function(){var t=this._self._c;return t("h2",{attrs:{id:"가비지-컬렉터의-원리"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#가비지-컬렉터의-원리"}},[this._v("#")]),this._v(" 가비지 컬렉터의 원리")])},function(){var t=this._self._c;return t("ol",[t("li",[this._v("메모리 할당")]),this._v(" "),t("li",[this._v("사용 중인 메모리 인식")]),this._v(" "),t("li",[this._v("사용하지 않는 메모리 인식")])])},function(){var t=this._self._c;return t("h2",{attrs:{id:"소유권-규칙"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#소유권-규칙"}},[this._v("#")]),this._v(" 소유권 규칙")])},function(){var t=this._self._c;return t("ol",[t("li",[this._v("러스트의 각각의 값은 해당값의 오너(owner)라고 불리우는 변수를 갖고 있다.")]),this._v(" "),t("li",[this._v("한번에 딱 하나의 오너만 존재할 수 있다.")]),this._v(" "),t("li",[this._v("오너가 스코프 밖으로 벗어나는 때, 값은 버려진다(dropped).")])])},function(){var t=this._self._c;return t("h2",{attrs:{id:"변수의-스코프"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#변수의-스코프"}},[this._v("#")]),this._v(" 변수의 스코프")])},function(){var t=this._self._c;return t("p",[t("code",[this._v("fn main(){")]),this._v(" 코드를 예제에 붙이지 않을텐, 여러분들이 코드를 따라하려면 "),t("code",[this._v("main")]),this._v("함수에 직접 예제들을 넣어야 할 겁니다. 결과적으로, 우리의 예제들은 좀더 간략해져서 보일러 플레이트 코드에 비해 실제 디테일에 초점을 맞출 수 있도록 해 줄 것입니다.")])},function(){var t=this._self._c;return t("p",[this._v("소유권에 대한 첫 에제로서, 변수들의 스코프를 보겠습니다. "),t("strong",[this._v("스코프란 프로그램 내에서 아이템이 유효함을 표시하기 위한 범위입니다.")]),this._v(" 아래 코드처럼 생긴 변수가 있다고 해 봅시다.")])},function(){var t=this._self._c;return t("div",{staticClass:"language-rust extra-class"},[t("pre",{pre:!0,attrs:{class:"language-rust"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[this._v("let")]),this._v(" s "),t("span",{pre:!0,attrs:{class:"token operator"}},[this._v("=")]),this._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[this._v('"hello"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[this._v(";")]),this._v("\n")])])])},function(){var t=this._self._c;return t("p",[this._v("변수 "),t("code",[this._v("s")]),this._v("는 스트링 리터럴을 나타나는데, 스트링 리터럴의 값은 우리의 프로그램의 텍스트 내에 하드코딩되어 있습니다. 변수는 선언된 시점부터 현재의 스코프가 끝날 때까지 유효합니다. 아래 예제 Listing 4-1은 변수 "),t("code",[this._v("s")]),this._v("가 유효한 지점을 주석으로 표시했습니다.")])},function(){var t=this,s=t._self._c;return s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("                      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// s는 유효하지 않습니다. 아직 선언이 안됐거든요.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// s는 이 지점부터 유효합니다.")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// s를 가지고 뭔가 합니다.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("                      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 이 스코프는 이제 끝이므로, s는 더이상 유효하지 않습니다.")]),t._v("\n")])])])},function(){var t=this._self._c;return t("h2",{attrs:{id:"참고한-자료"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#참고한-자료"}},[this._v("#")]),this._v(" 참고한 자료")])},function(){var t=this._self._c;return t("li",[t("strong",[this._v("Rust 소유권:")])])}],!1,null,null,null);s.default=_.exports}}]);